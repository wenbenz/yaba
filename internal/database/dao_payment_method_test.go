package database_test

import (
	"database/sql"
	"testing"
	"time"
	"yaba/internal/ctxutil"
	"yaba/internal/database"
	"yaba/internal/model"
	"yaba/internal/test/helper"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stretchr/testify/require"
	"golang.org/x/net/context"
)

func TestCreateAndGetPaymentMethod(t *testing.T) {
	t.Parallel()

	pool := helper.GetTestPool()
	ctx := t.Context()

	testCases := []struct {
		name   string
		method *model.PaymentMethod
	}{
		{
			name: "valid reward card",
			method: &model.PaymentMethod{
				ID:           uuid.New(),
				Owner:        uuid.New(),
				DisplayName:  "Freedom Flex Card",
				CardType:     newTestRewardCard(ctx, pool),
				AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
				CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
			},
		},
		{
			name: "valid debit card",
			method: &model.PaymentMethod{
				ID:           uuid.New(),
				Owner:        uuid.New(),
				DisplayName:  "Debit Card",
				CardType:     uuid.Nil,
				AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
				CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
			},
		},
		{
			name: "minimum info",
			method: &model.PaymentMethod{
				ID:    uuid.New(), // needed for test, but otherwise can be generated by DB.
				Owner: uuid.New(),
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			ctx := context.WithValue(t.Context(), ctxutil.CTXUser, tc.method.Owner)
			err := database.CreatePaymentMethod(ctx, pool, tc.method)
			require.NoError(t, err)

			stored, err := database.GetPaymentMethod(ctx, pool, tc.method.ID)
			require.NoError(t, err)

			require.Equal(t, tc.method.ID, stored.ID)
			require.Equal(t, tc.method.Owner, stored.Owner)
			require.Equal(t, tc.method.DisplayName, stored.DisplayName)
			require.Equal(t, tc.method.CardType, stored.CardType)
			require.Equal(t, tc.method.AcquiredDate.Time.UTC(), stored.AcquiredDate.Time.UTC())
			require.Equal(t, tc.method.CancelByDate.Time.UTC(), stored.CancelByDate.Time.UTC())

			if tc.method.CardType != uuid.Nil {
				require.Equal(t, &model.RewardCard{
					ID:         tc.method.CardType,
					Name:       "Freedom Flex",
					Version:    1,
					Issuer:     "Chase",
					Region:     "USA",
					RewardType: "cash",
					RewardCategories: []*model.RewardCategory{
						{
							CardID:   tc.method.CardType,
							Category: "Groceries",
							Rate:     3.0,
						},
						{
							CardID:   tc.method.CardType,
							Category: "Transportation",
							Rate:     2.0,
						},
						{
							CardID:   tc.method.CardType,
							Category: "Other",
							Rate:     1.0,
						},
					},
				}, stored.Rewards)
			} else {
				require.Equal(t, &model.RewardCard{}, stored.Rewards)
			}
		})
	}
}

func TestCreatePaymentMethodForOtherUser(t *testing.T) {
	t.Parallel()

	pool := helper.GetTestPool()
	ctx := t.Context()
	contextUser := uuid.New()
	otherUser := uuid.New()
	ctx = context.WithValue(ctx, ctxutil.CTXUser, contextUser)

	method := &model.PaymentMethod{
		ID:           uuid.New(),
		Owner:        otherUser, // Attempting to create for different user
		DisplayName:  "Other User's Card",
		CardType:     uuid.Nil,
		AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
		CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
	}

	err := database.CreatePaymentMethod(ctx, pool, method)
	require.NoError(t, err)

	// Verify the payment method was created with context user as owner
	stored, err := database.GetPaymentMethod(ctx, pool, method.ID)
	require.NoError(t, err)
	require.Equal(t, contextUser, stored.Owner) // Should be context user, not otherUser

	// Verify other user cannot access the payment method
	otherCtx := context.WithValue(t.Context(), ctxutil.CTXUser, otherUser)
	_, err = database.GetPaymentMethod(otherCtx, pool, method.ID)
	require.Error(t, err)
}

func TestListPaymentMethods(t *testing.T) {
	t.Parallel()

	pool := helper.GetTestPool()
	ctx := t.Context()
	owner := uuid.New()
	ctx = context.WithValue(ctx, ctxutil.CTXUser, owner)

	// Create a reward card first
	rewardCard := &model.RewardCard{
		ID:      uuid.New(),
		Name:    "Freedom Flex",
		Version: 1,
		Issuer:  "Chase",
		Region:  "USA",

		RewardType: "cash",
	}
	err := database.CreateRewardCard(ctx, pool, rewardCard)
	require.NoError(t, err)

	// Create test payment methods
	methods := []*model.PaymentMethod{
		{
			ID:           uuid.New(),
			Owner:        owner,
			DisplayName:  "A - First Card",
			CardType:     rewardCard.ID,
			AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
			CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
		},
		{
			ID:           uuid.New(),
			Owner:        owner,
			DisplayName:  "B - Debit Card",
			CardType:     uuid.Nil,
			AcquiredDate: toNullTime(time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC)),
			CancelByDate: toNullTime(time.Date(2025, 2, 1, 0, 0, 0, 0, time.UTC)),
		},
		{
			ID:           uuid.New(),
			Owner:        owner,
			DisplayName:  "C - Another Card",
			CardType:     rewardCard.ID,
			AcquiredDate: toNullTime(time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC)),
			CancelByDate: toNullTime(time.Date(2025, 3, 1, 0, 0, 0, 0, time.UTC)),
		},
	}

	// Create payment methods in database
	for _, method := range methods {
		err := database.CreatePaymentMethod(ctx, pool, method)
		require.NoError(t, err)
	}

	// Create a payment method for different owner - shouldn't appear in list
	otherMethod := &model.PaymentMethod{
		ID:           uuid.New(),
		Owner:        uuid.New(),
		DisplayName:  "Other User's Card",
		CardType:     uuid.Nil,
		AcquiredDate: toNullTime(time.Now()),
		CancelByDate: toNullTime(time.Now().AddDate(1, 0, 0)),
	}
	otherCtx := context.WithValue(ctx, ctxutil.CTXUser, otherMethod.Owner)
	err = database.CreatePaymentMethod(otherCtx, pool, otherMethod)
	require.NoError(t, err)

	// List payment methods
	listed, err := database.ListPaymentMethods(ctx, pool)
	require.NoError(t, err)
	require.Len(t, listed, len(methods))

	// Verify order and content
	for i, method := range listed {
		require.Equal(t, methods[i].ID, method.ID)
		require.Equal(t, methods[i].Owner, method.Owner)
		require.Equal(t, methods[i].DisplayName, method.DisplayName)
		require.Equal(t, methods[i].CardType, method.CardType)
		require.Equal(t, methods[i].AcquiredDate.Time.UTC(), method.AcquiredDate.Time.UTC())
		require.Equal(t, methods[i].CancelByDate.Time.UTC(), method.CancelByDate.Time.UTC())
	}
}

func TestUpdatePaymentMethod(t *testing.T) {
	t.Parallel()

	pool := helper.GetTestPool()
	owner := uuid.New()
	otherUser := uuid.New()

	tests := []struct {
		name    string
		updater uuid.UUID
	}{
		{
			name:    "Same owner",
			updater: owner,
		},
		{
			name:    "Different owner",
			updater: otherUser,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			ctx := context.WithValue(t.Context(), ctxutil.CTXUser, owner)

			// Create initial payment method
			method := &model.PaymentMethod{
				ID:           uuid.New(),
				Owner:        owner,
				DisplayName:  "Initial Name",
				CardType:     uuid.Nil,
				AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
				CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
			}

			err := database.CreatePaymentMethod(ctx, pool, method)
			require.NoError(t, err)

			// Update payment method
			updatedMethod := &model.PaymentMethod{
				ID:           method.ID,
				Owner:        owner,
				DisplayName:  "Updated Name",
				CardType:     uuid.Nil,
				AcquiredDate: toNullTime(time.Date(2024, 2, 1, 0, 0, 0, 0, time.UTC)),
				CancelByDate: toNullTime(time.Date(2025, 2, 1, 0, 0, 0, 0, time.UTC)),
			}

			err = database.UpdatePaymentMethod(
				context.WithValue(t.Context(), ctxutil.CTXUser, tt.updater),
				pool,
				updatedMethod,
			)
			require.NoError(t, err)

			expected := updatedMethod
			if tt.updater != owner {
				expected = method
			}

			// Verify update
			stored, err := database.GetPaymentMethod(ctx, pool, method.ID)
			require.NoError(t, err)
			require.Equal(t, expected.ID, stored.ID)
			require.Equal(t, expected.Owner, stored.Owner)
			require.Equal(t, expected.DisplayName, stored.DisplayName)
			require.Equal(t, expected.CardType, stored.CardType)
			require.Equal(t, expected.AcquiredDate.Time.UTC(), stored.AcquiredDate.Time.UTC())
			require.Equal(t, expected.CancelByDate.Time.UTC(), stored.CancelByDate.Time.UTC())
		})
	}
}

func TestUpdatePaymentMethodDifferentUser(t *testing.T) {
	t.Parallel()

	pool := helper.GetTestPool()
	ctx := t.Context()
	originalOwner := uuid.New()
	ctx = context.WithValue(ctx, ctxutil.CTXUser, originalOwner)

	// Create initial payment method
	method := &model.PaymentMethod{
		ID:           uuid.New(),
		Owner:        originalOwner,
		DisplayName:  "Original Name",
		CardType:     uuid.Nil,
		AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
		CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
	}

	err := database.CreatePaymentMethod(ctx, pool, method)
	require.NoError(t, err)

	// Attempt update with different owner
	differentOwner := uuid.New()
	differentCtx := context.WithValue(t.Context(), ctxutil.CTXUser, differentOwner)

	updateAttempt := &model.PaymentMethod{
		ID:           method.ID,
		Owner:        differentOwner,
		DisplayName:  "Attempted Update",
		CardType:     uuid.Nil,
		AcquiredDate: toNullTime(time.Now()),
		CancelByDate: toNullTime(time.Now().AddDate(1, 0, 0)),
	}

	err = database.UpdatePaymentMethod(differentCtx, pool, updateAttempt)
	require.NoError(t, err) // SQL succeeds but affects 0 rows

	// Verify original data remains unchanged
	stored, err := database.GetPaymentMethod(ctx, pool, method.ID)
	require.NoError(t, err)
	require.Equal(t, method.Owner, stored.Owner)
	require.Equal(t, method.DisplayName, stored.DisplayName)
	require.Equal(t, method.AcquiredDate.Time.UTC(), stored.AcquiredDate.Time.UTC())
	require.Equal(t, method.CancelByDate.Time.UTC(), stored.CancelByDate.Time.UTC())

	// Verify different owner cannot retrieve the payment method
	_, err = database.GetPaymentMethod(differentCtx, pool, method.ID)
	require.Error(t, err)
}

func TestDeletePaymentMethod(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name           string
		deleterIsOwner bool
	}{
		{
			name:           "owner can delete",
			deleterIsOwner: true,
		},
		{
			name:           "non-owner cannot delete",
			deleterIsOwner: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			pool := helper.GetTestPool()
			owner := uuid.New()
			ctx := context.WithValue(t.Context(), ctxutil.CTXUser, owner)

			// Create payment method
			method := &model.PaymentMethod{
				ID:           uuid.New(),
				Owner:        owner,
				DisplayName:  "Test Card",
				CardType:     uuid.Nil,
				AcquiredDate: toNullTime(time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)),
				CancelByDate: toNullTime(time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)),
			}

			err := database.CreatePaymentMethod(ctx, pool, method)
			require.NoError(t, err)

			// Attempt deletion
			deleteCtx := ctx
			if !tt.deleterIsOwner {
				deleteCtx = context.WithValue(t.Context(), ctxutil.CTXUser, uuid.New())
			}

			anyDeleted, err := database.DeletePaymentMethod(deleteCtx, pool, method.ID)
			require.NoError(t, err) // SQL succeeds but may affect 0 rows
			require.Equal(t, tt.deleterIsOwner, anyDeleted)

			// Verify if payment method still exists
			stored, err := database.GetPaymentMethod(ctx, pool, method.ID)
			if tt.deleterIsOwner {
				require.Error(t, err) // Should not find the deleted method
				require.Nil(t, stored)
			} else {
				require.NoError(t, err) // Should still find the method
				require.Equal(t, method.ID, stored.ID)
				require.Equal(t, method.Owner, stored.Owner)
				require.Equal(t, method.DisplayName, stored.DisplayName)
			}
		})
	}
}

func newTestRewardCard(ctx context.Context, pool *pgxpool.Pool) uuid.UUID {
	// Create reward cards first
	cardID := uuid.New()
	rewardCard := &model.RewardCard{
		ID:         cardID,
		Name:       "Freedom Flex",
		Version:    1,
		Issuer:     "Chase",
		Region:     "USA",
		RewardType: "cash",
		RewardCategories: []*model.RewardCategory{
			{
				CardID:   cardID,
				Category: "Groceries",
				Rate:     3.0,
			},
			{
				CardID:   cardID,
				Category: "Transportation",
				Rate:     2.0,
			},
			{
				CardID:   cardID,
				Category: "Other",
				Rate:     1.0,
			},
		},
	}
	_ = database.CreateRewardCard(ctx, pool, rewardCard)

	return rewardCard.ID
}

func toNullTime(t time.Time) sql.NullTime {
	return sql.NullTime{
		Time:  t,
		Valid: !t.IsZero(),
	}
}

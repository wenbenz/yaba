package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"strconv"
	"time"
	"yaba/internal/constants"
	"yaba/internal/database"
	"yaba/internal/graph/model"

	"github.com/google/uuid"
)

// Expenditure is the resolver for the expenditure field.
func (r *queryResolver) Expenditure(ctx context.Context, since *string, until *string, count *int) ([]*model.Expenditure, error) {
	sinceTime, err := time.Parse(time.RFC3339, *since)
	if err != nil {
		return []*model.Expenditure{}, err
	}

	untilTime, err := time.Parse(time.RFC3339, *until)
	if err != nil {
		return []*model.Expenditure{}, err
	}

	expenditures, err := database.ListExpenditures(ctx, r.Pool, ctx.Value(constants.CTXUser).(uuid.UUID), sinceTime, untilTime, *count);
	if err != nil {
		return []*model.Expenditure{}, err
	}

	ret := make([]*model.Expenditure, len(expenditures))
	for i, obj := range expenditures {
		id := strconv.Itoa(obj.ID)
		owner := obj.Owner.String()
		amount := fmt.Sprintf("%.2f", obj.Amount)
		date := obj.Date.Format(time.DateOnly)
		cat := obj.RewardCategory.String
		created := obj.CreatedTime.Format(time.RFC3339)

		ret[i] = &model.Expenditure{
			ID: &id,
			Owner: &owner,
			Name: &obj.Name,
			Amount: &amount,
			Date: &date,
			Method: &obj.Method,
			BudgetCategory: &obj.BudgetCategory,
			RewardCategory: &cat,
			Comment: &obj.Comment,
			Created: &created,
			Source: &obj.Source,
		}
	}

	return ret, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
